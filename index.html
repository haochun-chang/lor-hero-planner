<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LOR月本 英雄配置</title>
  <style>
    body { font-family: system-ui, -apple-system, "PingFang TC", "Noto Sans TC", sans-serif; margin:0; }
    header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid #ddd; padding: 10px 12px; z-index: 10; }
    .meta { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .small { font-size: 12px; color:#444; }
    .actions { display:flex; gap:8px; flex-wrap: wrap; margin-top: 8px; }
    button { padding: 8px 10px; }
    .msg-ok { color:#0a7a0a; font-size: 13px; margin-top:6px; }
    .msg-warn { color:#b00020; font-size: 13px; margin-top:6px; }

    .row { display:flex; gap: 10px; align-items:center; padding:8px 12px; border-bottom:1px solid #eee; }
    .lvl { width: 74px; flex: 0 0 auto; }
    .chooser { flex: 1 1 auto; }
    .count { width: 54px; text-align:right; font-size:12px; color:#444; }

    .panel { padding: 10px 12px; border-bottom: 1px solid #eee; background:#fafafa; }
    textarea { width: 100%; height: 160px; box-sizing: border-box; padding: 8px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .modalBackdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display:none; align-items: center; justify-content: center; z-index: 999; padding: 12px; }
    .modal { background: #fff; width: min(560px, 100%); border-radius: 14px; padding: 12px; max-height: 80vh; overflow:auto; }
    input[type="text"] { padding: 8px 10px; width: 100%; box-sizing: border-box; }
    .heroList { display:grid; grid-template-columns: 1fr; gap: 8px; margin-top: 10px; }
    .heroBtn { display:flex; justify-content: space-between; align-items:center; width: 100%; padding: 10px; border:1px solid #ddd; border-radius: 12px; background:#fff; text-align:left; }
    .heroBtn[disabled] { opacity: .45; }
  </style>
</head>
<body>

<header>
  <div class="meta">
    <b>LOR月本 英雄配置</b>
    <span class="small">規則：每英雄最多 <b>3</b> 次</span>
    <span id="heroCount" class="small"></span>
  </div>

  <div id="msg" class="msg-ok">已載入</div>

  <div class="actions">
    <button id="btnSetNames">設定英雄名單（貼上）</button>
    <button id="btnClear">清空全部</button>
    <button id="btnExport">匯出</button>
    <button id="btnImport">匯入</button>
  </div>

  <!-- 匯入/匯出區 -->
  <div id="ioArea" class="panel" style="display:none;">
    <div class="small">匯出/匯入文字：</div>
    <textarea id="ioText" class="kbd" placeholder="這裡會顯示匯出文字，或貼上匯入文字…"></textarea>
    <div class="actions">
      <button id="btnApplyImport">套用匯入</button>
      <button id="btnCloseIO">關閉</button>
    </div>
  </div>

  <!-- 英雄名單貼上區 -->
  <div id="nameArea" class="panel" style="display:none;">
    <div class="small">
      <b>貼上英雄真名（每行一個）</b>：貼幾行，就會有幾隻英雄（自動編號 H01, H02…）
    </div>
    <textarea id="nameText" class="kbd" placeholder="例如：&#10;亞瑟&#10;露娜&#10;…"></textarea>
    <div class="actions">
      <button id="btnApplyNames">套用名單</button>
      <button id="btnCloseNames">關閉</button>
    </div>
    <div class="small" style="margin-top:6px;">
      注意：如果你把英雄數量變少，超出範圍的關卡選擇會自動清空。
    </div>
  </div>
</header>

<div id="list"></div>

<!-- 選英雄 Modal -->
<div id="modalBackdrop" class="modalBackdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="meta">
      <b id="modalTitle">選擇英雄</b>
      <span id="modalHint" class="small"></span>
    </div>

    <div style="margin-top:10px;">
      <input id="heroSearch" type="text" placeholder="搜尋英雄（可打 H01 或名字）" />
    </div>

    <div class="actions" style="margin-top:10px;">
      <button id="btnUnset">設為未選</button>
      <button id="btnCloseModal">關閉</button>
    </div>

    <div id="heroList" class="heroList"></div>
  </div>
</div>

<script>
  // ===== 設定 =====
  const LEVELS = 70;
  const LIMIT = 3;

  const STORAGE_KEY_PLAN  = "hero_planner_v3_plan";
  const STORAGE_KEY_NAMES = "hero_planner_v3_names";

  function heroId(i1based) { return `H${String(i1based).padStart(2,'0')}`; }

  // heroNamesLines: ["亞瑟","露娜",...]
  let heroNamesLines = [];
  // selections: length=70, each is heroId like "H01" or ""
  let selections = Array(LEVELS).fill("");
  // counts: { "H01": 2, ... } derived
  let counts = {};

  // ===== DOM =====
  const listEl = document.getElementById("list");
  const msgEl = document.getElementById("msg");
  const heroCountEl = document.getElementById("heroCount");

  const btnSetNames = document.getElementById("btnSetNames");
  const nameArea = document.getElementById("nameArea");
  const nameText = document.getElementById("nameText");
  const btnApplyNames = document.getElementById("btnApplyNames");
  const btnCloseNames = document.getElementById("btnCloseNames");

  const btnClear = document.getElementById("btnClear");
  const btnExport = document.getElementById("btnExport");
  const btnImport = document.getElementById("btnImport");
  const ioArea = document.getElementById("ioArea");
  const ioText = document.getElementById("ioText");
  const btnApplyImport = document.getElementById("btnApplyImport");
  const btnCloseIO = document.getElementById("btnCloseIO");

  const modalBackdrop = document.getElementById("modalBackdrop");
  const modalTitle = document.getElementById("modalTitle");
  const modalHint = document.getElementById("modalHint");
  const heroSearch = document.getElementById("heroSearch");
  const heroList = document.getElementById("heroList");
  const btnUnset = document.getElementById("btnUnset");
  const btnCloseModal = document.getElementById("btnCloseModal");

  // modal 狀態
  let activeLevel = null;
  let modalOpen = false;

  // ===== 工具 =====
  function setMessage(text, warn=false) {
    msgEl.className = warn ? "msg-warn" : "msg-ok";
    msgEl.textContent = text;
  }

  function heroCount() {
    return heroNamesLines.length; // 貼幾行就幾隻
  }

  function getHeroName(id) {
    // 若 id = H01，取第1行；沒有就顯示 id
    const idx = parseInt(id.slice(1), 10) - 1;
    return (heroNamesLines[idx] && heroNamesLines[idx].trim()) ? heroNamesLines[idx].trim() : id;
  }

  function validHeroSet() {
    const n = heroCount();
    const s = new Set();
    for (let i = 1; i <= n; i++) s.add(heroId(i));
    return s;
  }

  function recomputeCounts() {
    counts = {};
    const n = heroCount();
    for (let i = 1; i <= n; i++) counts[heroId(i)] = 0;
    for (const h of selections) {
      if (h && counts[h] !== undefined) counts[h]++;
    }
  }

  function normalizeSelectionsToHeroList() {
    // 若英雄名單變少，超出範圍的選擇清空
    const set = validHeroSet();
    let cleared = 0;
    for (let i = 0; i < selections.length; i++) {
      const h = selections[i];
      if (h && !set.has(h)) {
        selections[i] = "";
        cleared++;
      }
    }
    return cleared;
  }

  function savePlan() {
    localStorage.setItem(STORAGE_KEY_PLAN, JSON.stringify({ selections }));
  }
  function saveNames() {
    localStorage.setItem(STORAGE_KEY_NAMES, JSON.stringify({ heroNamesLines }));
  }

  function loadAll() {
    // names
    try {
      const rawN = localStorage.getItem(STORAGE_KEY_NAMES);
      if (rawN) {
        const data = JSON.parse(rawN);
        if (data && Array.isArray(data.heroNamesLines)) heroNamesLines = data.heroNamesLines;
      }
    } catch(e) {}

    // plan
    try {
      const rawP = localStorage.getItem(STORAGE_KEY_PLAN);
      if (rawP) {
        const data = JSON.parse(rawP);
        if (data && Array.isArray(data.selections) && data.selections.length === LEVELS) {
          selections = data.selections.map(x => (typeof x === "string" ? x : ""));
        }
      }
    } catch(e) {}

    // 若還沒貼名單，使用內建預設（你提供的名單，共 82 隻）
    if (heroNamesLines.length === 0) {
      heroNamesLines = [
        "Aatrox",
        "Ahri",
        "Akshan",
        "Ambessa",
        "Anivia",
        "Annie",
        "Ashe",
        "Aurelion Sol",
        "Azir",
        "Bard",
        "Caitlyn",
        "Darius",
        "Diana",
        "Ekko",
        "Elder Dragon",
        "Elise",
        "Evelynn",
        "Fiddlesticks",
        "Garen",
        "Gnar",
        "Gwen",
        "Heimerdinger",
        "Illoai",
        "Jack",
        "Janna",
        "Jax",
        "Jayce",
        "Jhin",
        "Jinx",
        "Kaisa",
        "Kayle",
        "Kayn",
        "Kindred",
        "Leblanc",
        "Lee Sin",
        "Leona",
        "Lillia",
        "Lux",
        "Lux: Illuminated",
        "Master Yi",
        "Mel",
        "Miss Fortune",
        "Mordekaiser",
        "Morgana",
        "Nami",
        "Nasus",
        "Nautilus",
        "Neeko",
        "Nidalee",
        "Nilah",
        "Norra",
        "Ornn",
        "Pyke",
        "Samira",
        "Sett",
        "Shyvana",
        "Soraka",
        "Spirit Blossom Ahri",
        "Spirit Blossom Evelynn",
        "Spirit Blossom Kindred",
        "Spirit Blossom Master Yi",
        "Spirit Blossom Teemo",
        "Spirit Blossom Yasuo",
        "Swain",
        "Tahm Kench",
        "Taliyah",
        "Teemo",
        "The Poro King",
        "Thresh",
        "Tryndamere",
        "Twisted Fate",
        "Varus",
        "Vayne",
        "Veigar",
        "Vex",
        "Vi",
        "Viego",
        "Victor",
        "Volibear",
        "Warwick",
        "Yasuo",
        "Yummi"
      ];
    }

    const cleared = normalizeSelectionsToHeroList();
    recomputeCounts();

    if (cleared > 0) setMessage(`⚠️ 英雄名單變更，已自動清空 ${cleared} 個超出範圍的選擇`, true);
  }

  function updateHeroCountLabel() {
    heroCountEl.textContent = `英雄數：${heroCount()} 隻`;
  }

  function renderRows() {
    listEl.innerHTML = "";
    for (let i = 0; i < LEVELS; i++) {
      const row = document.createElement("div");
      row.className = "row";

      const lvl = document.createElement("div");
      lvl.className = "lvl";
      lvl.innerHTML = `<b>第${i+1}關</b>`;
      row.appendChild(lvl);

      const btn = document.createElement("button");
      btn.className = "chooser";
      const cur = selections[i];
      btn.textContent = cur ? `已選：${getHeroName(cur)}（點我更改）` : "未選（點我選英雄）";
      btn.addEventListener("click", () => openModal(i));
      row.appendChild(btn);

      const c = document.createElement("div");
      c.className = "count";
      if (cur && counts[cur] !== undefined) c.textContent = `${counts[cur]}/${LIMIT}`;
      row.appendChild(c);

      listEl.appendChild(row);
    }
  }

  function canPick(heroIdStr, levelIdx) {
    const cur = selections[levelIdx];
    if (cur === heroIdStr) return true;
    return (counts[heroIdStr] || 0) < LIMIT;
  }

  function applySelection(levelIdx, newHeroId) {
    const old = selections[levelIdx];
    if (old === newHeroId) return;

    // 增量更新
    if (old && counts[old] !== undefined) counts[old]--;
    if (newHeroId && counts[newHeroId] !== undefined) counts[newHeroId]++;

    // 超限回退
    if (newHeroId && counts[newHeroId] > LIMIT) {
      counts[newHeroId]--;
      if (old && counts[old] !== undefined) counts[old]++;
      setMessage(`❌ ${getHeroName(newHeroId)} 已超過上限（最多 ${LIMIT} 次）`, true);
      return;
    }

    selections[levelIdx] = newHeroId || "";
    savePlan();
    renderRows();
    if (modalOpen) renderHeroList(heroSearch.value.trim());
    setMessage("✅ 已更新（自動儲存）", false);
  }

  // ===== Modal =====
  function openModal(levelIdx) {
    activeLevel = levelIdx;
    modalOpen = true;
    modalBackdrop.style.display = "flex";
    modalTitle.textContent = `第${levelIdx+1}關：選擇英雄`;
    const cur = selections[levelIdx];
    modalHint.textContent = cur ? `目前：${getHeroName(cur)}（${counts[cur]||0}/${LIMIT}）` : "目前：未選";

    heroSearch.value = "";
    renderHeroList("");
    setTimeout(() => heroSearch.focus(), 0);
  }

  function closeModal() {
    modalOpen = false;
    modalBackdrop.style.display = "none";
    activeLevel = null;
  }

  function renderHeroList(query) {
    heroList.innerHTML = "";
    const q = (query || "").toLowerCase();
    const n = heroCount();

    for (let i = 1; i <= n; i++) {
      const id = heroId(i);
      const name = getHeroName(id);
      const c = counts[id] || 0;

      if (q && !(id.toLowerCase().includes(q) || name.toLowerCase().includes(q))) continue;

      const btn = document.createElement("button");
      btn.className = "heroBtn";

      const left = document.createElement("div");
      left.innerHTML = `<b>${name}</b> <span class="small">(${id})</span>`;

      const right = document.createElement("div");
      right.className = "small";
      right.textContent = `${c}/${LIMIT}` + (c >= LIMIT ? " 已滿" : "");

      btn.appendChild(left);
      btn.appendChild(right);

      btn.disabled = !canPick(id, activeLevel);
      btn.addEventListener("click", () => {
        applySelection(activeLevel, id);
        closeModal();
      });

      heroList.appendChild(btn);
    }
  }

  // ===== 匯入/匯出 =====
  function exportText() {
    const payload = {
      v: 3,
      heroNamesLines,
      selections
    };
    return btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  }

  function importText(text) {
    const raw = decodeURIComponent(escape(atob(text.trim())));
    const data = JSON.parse(raw);

    if (!data || !Array.isArray(data.selections) || data.selections.length !== LEVELS) {
      throw new Error("匯入格式不正確（缺 selections 或長度不是 70）");
    }
    if (!Array.isArray(data.heroNamesLines) || data.heroNamesLines.length === 0) {
      throw new Error("匯入格式不正確（缺 heroNamesLines 名單）");
    }

    heroNamesLines = data.heroNamesLines.map(x => String(x || "").trim()).filter(x => x.length > 0);
    if (heroNamesLines.length === 0) throw new Error("英雄名單為空");

    selections = data.selections.map(x => (typeof x === "string" ? x : ""));
    const cleared = normalizeSelectionsToHeroList();
    recomputeCounts();

    // 這裡再做一次超限檢查（保險）
    for (let i = 1; i <= heroCount(); i++) {
      const id = heroId(i);
      if ((counts[id] || 0) > LIMIT) throw new Error(`匯入內容超過上限：${getHeroName(id)}`);
    }

    saveNames();
    savePlan();
    updateHeroCountLabel();
    renderRows();

    if (cleared > 0) setMessage(`✅ 匯入成功（並清空 ${cleared} 個超出名單的選擇）`, true);
    else setMessage("✅ 匯入成功", false);
  }

  // ===== 英雄名單貼上 =====
  function applyNamesFromTextarea() {
    const lines = nameText.value
      .split(/\r?\n/)
      .map(s => s.trim())
      .filter(s => s.length > 0);

    if (lines.length === 0) {
      setMessage("❌ 名單是空的：請至少貼 1 行英雄名稱", true);
      return;
    }

    heroNamesLines = lines;
    const cleared = normalizeSelectionsToHeroList();
    recomputeCounts();

    saveNames();
    savePlan();
    updateHeroCountLabel();
    renderRows();

    if (cleared > 0) setMessage(`✅ 已套用名單（並清空 ${cleared} 個超出範圍的選擇）`, true);
    else setMessage("✅ 已套用名單", false);
  }

  // ===== 事件 =====
  btnSetNames.addEventListener("click", () => {
    nameArea.style.display = "block";
    ioArea.style.display = "none";
    nameText.value = heroNamesLines.join("\n");
    nameText.focus();
    setMessage("貼上英雄名單後按「套用名單」", false);
  });

  btnApplyNames.addEventListener("click", applyNamesFromTextarea);
  btnCloseNames.addEventListener("click", () => nameArea.style.display = "none");

  btnClear.addEventListener("click", () => {
    selections = Array(LEVELS).fill("");
    recomputeCounts();
    savePlan();
    renderRows();
    setMessage("✅ 已清空", false);
  });

  btnExport.addEventListener("click", () => {
    ioArea.style.display = "block";
    nameArea.style.display = "none";
    ioText.value = exportText();
    ioText.focus(); ioText.select();
    setMessage("✅ 已產生匯出文字（可複製分享）", false);
  });

  btnImport.addEventListener("click", () => {
    ioArea.style.display = "block";
    nameArea.style.display = "none";
    ioText.value = "";
    ioText.focus();
    setMessage("把匯出文字貼上後按「套用匯入」", false);
  });

  btnApplyImport.addEventListener("click", () => {
    try {
      importText(ioText.value);
    } catch (e) {
      setMessage("❌ 匯入失敗：" + (e.message || "未知錯誤"), true);
    }
  });

  btnCloseIO.addEventListener("click", () => {
    ioArea.style.display = "none";
    ioText.value = "";
  });

  heroSearch.addEventListener("input", () => renderHeroList(heroSearch.value.trim()));
  btnCloseModal.addEventListener("click", closeModal);
  modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); });
  btnUnset.addEventListener("click", () => {
    if (activeLevel !== null) applySelection(activeLevel, "");
    closeModal();
  });

  // ===== 啟動 =====
  loadAll();
  updateHeroCountLabel();
  renderRows();
  if (msgEl.textContent === "已載入") setMessage("✅ 已載入（會自動儲存）", false);
</script>

</body>
</html>